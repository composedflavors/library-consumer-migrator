/*
 * This source file was generated by the Gradle 'init' task
 */
package io.smokedsalmon.libraryconsumermigrator

import org.gradle.api.Project
import org.gradle.api.Plugin
import java.io.File

class LibraryConsumerMigratorPlugin : Plugin<Project> {

    override fun apply(project: Project) {
        project.tasks.register("migrateConsumerApp") { task ->
            task.group = "setup"
            task.description = "Import example application project as a submodule for testing with library modules"

            task.doLast {
                val submodulePath = project.getRequiredProperty("submodulePath")
                val submoduleName = project.findProperty("submoduleName") as? String ?: DEFAULT_SUBMODULE_NAME

                println("Importing example application as test submodule...")

                addGitSubmodule(project, submodulePath, submoduleName)
                removeStandaloneProjectFiles(project, submoduleName)
                mergeDependenciesToRoot(project, submoduleName)
                updateExampleBuildGradle(project, submoduleName)
                updateSettingsGradle(project, submoduleName)
                updateRootBuildGradle(project)

                printSuccessMessage(submoduleName)
            }
        }
    }

    private fun addGitSubmodule(project: Project, submodulePath: String, submoduleName: String) {
        println("Adding git submodule from $submodulePath...")

        val branch = project.findProperty("branch") as? String
        val submoduleDir = File(project.rootDir, submoduleName)

        if (submoduleDir.existsWithContent()) {
            updateExistingSubmodule(project, submoduleDir, submoduleName, branch)
            return
        }

        val addCommand = buildGitCommand("submodule", "add", branch = branch, path = submodulePath, name = submoduleName)
        project.executeGitCommand(addCommand)

        initializeAndUpdateSubmodule(project, submoduleName)

        if (!verifySubmoduleContent(submoduleDir)) {
            cloneAsFallback(project, submodulePath, submoduleName, branch)
        }
    }

    private fun updateExistingSubmodule(project: Project, submoduleDir: File, submoduleName: String, branch: String?) {
        println("  Directory exists, updating...")

        branch?.let {
            project.executeGitCommand(listOf("git", "checkout", it), workingDir = submoduleDir)
        }

        project.executeGitCommand(
            listOf("git", "submodule", "update", "--init", "--recursive", "--remote", submoduleName)
        )
    }

    private fun initializeAndUpdateSubmodule(project: Project, submoduleName: String) {
        project.executeGitCommand(listOf("git", "submodule", "init", submoduleName))
        project.executeGitCommand(
            listOf("git", "submodule", "update", "--init", "--recursive", submoduleName)
        )
    }

    private fun verifySubmoduleContent(submoduleDir: File): Boolean {
        return if (submoduleDir.existsWithContent()) {
            println("  Submodule downloaded (${submoduleDir.listFiles()?.size ?: 0} items)")
            true
        } else {
            println("  Submodule directory empty, trying fallback...")
            false
        }
    }

    private fun cloneAsFallback(project: Project, submodulePath: String, submoduleName: String, branch: String?) {
        val submoduleDir = File(project.rootDir, submoduleName)
        submoduleDir.deleteRecursively()

        val cloneCommand = buildGitCommand("clone", branch = branch, path = submodulePath, name = submoduleName)
        val cloneResult = project.executeGitCommand(cloneCommand)

        if (cloneResult == 0) {
            println("  Direct clone successful")
            addToGitmodules(project, submodulePath, submoduleName, branch)
        } else {
            throw RuntimeException("Failed to download submodule from $submodulePath")
        }
    }

    private fun addToGitmodules(project: Project, submodulePath: String, submoduleName: String, branch: String?) {
        val gitmodulesFile = File(project.rootDir, ".gitmodules")
        val gitmodulesContent = buildString {
            appendLine("[submodule \"$submoduleName\"]")
            appendLine("\tpath = $submoduleName")
            appendLine("\turl = $submodulePath")
            branch?.let { appendLine("\tbranch = $it") }
        }
        gitmodulesFile.appendText(gitmodulesContent)
    }

    private fun removeStandaloneProjectFiles(project: Project, submoduleName: String) {
        println("Removing standalone project files...")

        val submoduleDir = File(project.rootDir, submoduleName)

        STANDALONE_FILES.forEach { filename ->
            File(submoduleDir, filename).takeIf { it.exists() }?.delete()
        }

        STANDALONE_DIRECTORIES.forEach { dirName ->
            File(submoduleDir, dirName).takeIf { it.exists() }?.deleteRecursively()
        }
    }

    private fun mergeDependenciesToRoot(project: Project, submoduleName: String) {
        println("Merging dependencies to root libs.versions.toml...")

        val exampleLibsFile = File(project.rootDir, "$submoduleName/gradle/libs.versions.toml")
        val rootLibsFile = File(project.rootDir, "gradle/libs.versions.toml")

        if (!exampleLibsFile.exists() || !rootLibsFile.exists()) {
            println("  Version catalog not found, skipping merge")
            return
        }

        val exampleContent = exampleLibsFile.readText()
        val rootContent = rootLibsFile.readText()

        val exampleSections = TOML_SECTIONS.associateWith { extractSectionMap(exampleContent, it) }
        val rootSections = TOML_SECTIONS.associateWith { extractSectionMap(rootContent, it) }

        val newSections = TOML_SECTIONS.associateWith { section ->
            exampleSections[section]!!.filterKeys { !rootSections[section]!!.containsKey(it) }
        }

        val totalNew = newSections.values.sumOf { it.size }

        if (totalNew > 0) {
            val updatedContent = mergeNewSectionsToContent(rootContent, newSections, submoduleName)
            rootLibsFile.writeText(updatedContent)
            println("  Added $totalNew new dependencies")
        } else {
            println("  No new dependencies to merge")
        }

        cleanupExampleVersionCatalog(exampleLibsFile, submoduleName)
    }

    private fun mergeNewSectionsToContent(
        content: String,
        newSections: Map<String, Map<String, String>>,
        submoduleName: String
    ): String {
        var updatedContent = content

        newSections.forEach { (sectionName, entries) ->
            if (entries.isNotEmpty()) {
                val newContent = "\n# Merged from $submoduleName\n" +
                        entries.map { (key, value) -> "$key = $value" }.joinToString("\n")
                updatedContent = appendToSection(updatedContent, sectionName, newContent)
            }
        }

        return updatedContent
    }

    private fun cleanupExampleVersionCatalog(exampleLibsFile: File, submoduleName: String) {
        exampleLibsFile.delete()

        val exampleGradleDir = File(exampleLibsFile.parentFile.path)
        if (exampleGradleDir.exists() && exampleGradleDir.listFiles()?.isEmpty() == true) {
            exampleGradleDir.delete()
        }
    }

    private fun extractSectionMap(content: String, sectionName: String): Map<String, String> {
        val sectionPattern = Regex("""\[$sectionName\](.*?)(?=\n\[|\z)""", RegexOption.DOT_MATCHES_ALL)
        val match = sectionPattern.find(content) ?: return emptyMap()

        val result = mutableMapOf<String, String>()
        val lines = match.groupValues[1].trim().lines()

        var currentKey: String? = null
        var currentValue = StringBuilder()

        for (line in lines) {
            val trimmed = line.trim()
            if (trimmed.isBlank() || trimmed.startsWith("#")) continue

            val equalsIndex = trimmed.indexOf('=')
            if (equalsIndex > 0 && !trimmed.startsWithWhitespace()) {
                currentKey?.let { result[it] = currentValue.toString().trim() }

                currentKey = trimmed.substring(0, equalsIndex).trim()
                currentValue = StringBuilder(trimmed.substring(equalsIndex + 1).trim())
            } else if (currentKey != null) {
                currentValue.append(" ").append(trimmed)
            }
        }

        currentKey?.let { result[it] = currentValue.toString().trim() }

        return result
    }

    private fun appendToSection(content: String, sectionName: String, newContent: String): String {
        val sectionPattern = Regex("""(\[$sectionName\])(.*?)(?=\n\[|\z)""", RegexOption.DOT_MATCHES_ALL)

        return sectionPattern.replace(content) { matchResult ->
            val sectionHeader = matchResult.groupValues[1]
            val sectionContent = matchResult.groupValues[2]
            "$sectionHeader$sectionContent$newContent\n"
        }
    }

    private fun updateExampleBuildGradle(project: Project, submoduleName: String) {
        println("Updating example's build.gradle.kts...")

        val buildFile = File(project.rootDir, "$submoduleName/build.gradle.kts")
        if (!buildFile.exists()) {
            val appBuildFile = File(project.rootDir, "$submoduleName/app/build.gradle.kts")
            if (!appBuildFile.exists()) {
                println("  build.gradle.kts not found")
                return
            }
        }

        println("  Example project will use root's version catalog")
    }

    private fun updateSettingsGradle(project: Project, submoduleName: String) {
        println("Updating settings.gradle.kts...")

        val settingsFile = File(project.rootDir, "settings.gradle.kts")
        if (!settingsFile.exists()) {
            val settingsFileGroovy = File(project.rootDir, "settings.gradle")
            if (!settingsFileGroovy.exists()) {
                throw IllegalStateException("settings.gradle.kts not found in root directory")
            }
        }

        val content = settingsFile.readText()
        val submoduleDir = File(project.rootDir, submoduleName)
        val hasAppSubfolder = File(project.rootDir, "$submoduleName/app").exists()

        val includeStatement = if (hasAppSubfolder) {
            "include(\":$submoduleName:app\")"
        } else {
            "include(\":$submoduleName\")"
        }

        if (!content.contains(includeStatement)) {
            settingsFile.appendText("\n$includeStatement\n")
            println("  Added module to settings")
        }

        addAdditionalModules(settingsFile, content, submoduleDir, submoduleName)
    }

    private fun addAdditionalModules(settingsFile: File, content: String, submoduleDir: File, submoduleName: String) {
        submoduleDir.listFiles()
            ?.filter { it.isDirectory && File(it, "build.gradle.kts").exists() && it.name != "app" }
            ?.forEach { moduleDir ->
                val modulePath = ":$submoduleName:${moduleDir.name}"
                if (!content.contains(modulePath)) {
                    settingsFile.appendText("include(\"$modulePath\")\n")
                    println("  Added ${moduleDir.name} module")
                }
            }
    }

    private fun updateRootBuildGradle(project: Project) {
        println("Updating root build.gradle.kts...")

        val buildFile = File(project.rootDir, "build.gradle.kts")
        if (!buildFile.exists()) {
            println("  Root build.gradle.kts not found")
            return
        }

        var content = buildFile.readText()

        val hasPluginsBlock = content.contains("plugins {")
        val hasApplicationPlugin = content.contains("androidApplication")
        val hasLibraryPlugin = content.contains("androidLibrary")

        if (!hasPluginsBlock || !hasApplicationPlugin || !hasLibraryPlugin) {
            println("  Ensure root build.gradle.kts has: androidApplication and androidLibrary plugins")

            if (hasPluginsBlock && !hasApplicationPlugin) {
                val pluginToAdd = "    alias(libs.plugins.androidApplication) apply false"
                content = content.replaceFirst("plugins {", "plugins {\n$pluginToAdd")
                buildFile.writeText(content)
                println("  Added androidApplication plugin")
            }
        }
    }

    private fun printSuccessMessage(submoduleName: String) {
        println("\nâœ“ Example application imported successfully!")
        println("\nNext steps:")
        println("  1. Review merged dependencies in gradle/libs.versions.toml")
        println("  2. Add implementation(project(\":your-library\")) to $submoduleName/build.gradle.kts")
        println("  3. Sync project with Gradle files")
        println("  4. Run the example application to test your library")
    }

    // Extension functions and utilities

    private fun Project.getRequiredProperty(name: String): String =
        findProperty(name) as? String
            ?: throw IllegalArgumentException("Please provide -P$name=<value>")

    private fun Project.executeGitCommand(
        command: List<String>,
        workingDir: File = rootDir
    ): Int {
        val result = exec { exec ->
            exec.workingDir = workingDir
            exec.commandLine(command)
            exec.isIgnoreExitValue = true
        }
        return result.exitValue
    }

    private fun File.existsWithContent(): Boolean = exists() && listFiles()?.isNotEmpty() == true

    private fun String.startsWithWhitespace(): Boolean = startsWith(" ") || startsWith("\t")

    private fun String.capitalize(): String = replaceFirstChar { it.uppercase() }

    private fun buildGitCommand(
        command: String,
        vararg subcommands: String,
        branch: String? = null,
        path: String,
        name: String
    ): List<String> {
        return buildList {
            add("git")
            add(command)
            addAll(subcommands)
            branch?.let {
                add("-b")
                add(it)
            }
            add(path)
            add(name)
        }
    }

    companion object {
        private const val DEFAULT_SUBMODULE_NAME = "example-application"

        private val STANDALONE_FILES = listOf(
            "build.gradle.kts",
            "settings.gradle",
            "settings.gradle.kts",
            "gradlew",
            "gradlew.bat",
            "gradle.properties",
            "local.properties",
            ".gitignore"
        )

        private val STANDALONE_DIRECTORIES = listOf(
            "gradle/wrapper",
            ".gradle"
        )

        private val TOML_SECTIONS = listOf("versions", "libraries", "plugins")
    }
}